<!DOCTYPE html>
<!--
    üöÄ Crypto Dashboard - v2.1.3 KORRIGIERTE VERSION
    Behebt: Fehlende Charts, Trading Signals, Insights und Datenverarbeitung
-->
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Krypto Dashboard v2.1.3</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }

        .dashboard {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header */
        .dashboard-header {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .dashboard-header h1 {
            font-size: 2.2em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-stats {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .performance-btn {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .performance-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.3);
        }

        .stat-item {
            text-align: center;
            padding: 8px 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2d3748;
        }

        .stat-label {
            font-size: 0.8em;
            color: #718096;
        }

        .refresh-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(72, 187, 120, 0.4);
        }

        /* Controls */
        .controls {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-item label {
            font-weight: 600;
            color: #4a5568;
            font-size: 0.9em;
        }

        select, input {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.9em;
            min-width: 120px;
            transition: border-color 0.3s ease;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }

        .time-buttons {
            display: flex;
            gap: 5px;
        }

        .time-btn {
            padding: 6px 12px;
            background: #e2e8f0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
        }

        .time-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        /* KPI Cards */
        .kpi-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .kpi-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            text-align: center;
            transition: transform 0.3s ease;
        }

        .kpi-card:hover {
            transform: translateY(-5px);
        }

        .kpi-label {
            color: #718096;
            font-size: 0.85em;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .kpi-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .kpi-change {
            font-size: 1em;
            font-weight: 600;
        }

        .kpi-change.positive {
            color: #48bb78;
        }

        .kpi-change.negative {
            color: #f56565;
        }

        .kpi-change.neutral {
            color: #718096;
        }

        /* Trading Signal Styles */
        .trading-signal-buy {
            color: #48bb78 !important;
            background: linear-gradient(135deg, #48bb78, #38a169);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
        }

        .trading-signal-sell {
            color: #f56565 !important;
            background: linear-gradient(135deg, #f56565, #e53e3e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
        }

        .trading-signal-hold {
            color: #ed8936 !important;
            background: linear-gradient(135deg, #ed8936, #dd6b20);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
        }

        /* Charts */
        .charts-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .chart-container.main-chart {
            grid-column: span 2;
        }

        .chart-container h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
        }

        .main-chart .chart-wrapper {
            height: 400px;
        }

        /* Market Overview */
        .market-overview {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .market-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .market-card {
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .market-card-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .market-card-label {
            color: #718096;
            font-size: 0.8em;
            text-transform: uppercase;
        }

        /* Insights */
        .insights-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .insight-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .insight-card h3 {
            margin-bottom: 15px;
            color: #2d3748;
            font-size: 1.1em;
        }

        .insights-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .insight-item {
            padding: 12px 15px;
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            border-left: 4px solid #667eea;
            border-radius: 8px;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
        }

        .insight-item:hover {
            background: linear-gradient(135deg, #edf2f7, #e2e8f0);
            transform: translateX(5px);
        }

        .insight-icon {
            font-size: 1.2em;
            min-width: 20px;
        }

        .insight-item.critical {
            background: rgba(245, 101, 101, 0.1);
            border-left: 3px solid #f56565;
        }

        .insight-item.positive {
            background: rgba(72, 187, 120, 0.1);
            border-left: 3px solid #48bb78;
        }

        /* Connection Status */
        .connection-status {
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-block;
        }

        .connection-status.connected {
            background: #48bb78;
            color: white;
        }

        .connection-status.demo {
            background: #f59e0b;
            color: white;
        }

        .connection-status.error {
            background: #f56565;
            color: white;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: #718096;
        }

        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #e2e8f0;
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Debug Panel */
        .debug-panel {
            background: linear-gradient(135deg, #2d3748, #1a202c);
            color: #e2e8f0;
            padding: 20px;
            margin: 20px;
            border-radius: 12px;
            border-left: 4px solid #4299e1;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .dashboard-header {
                flex-direction: column;
                gap: 15px;
            }
            .kpi-section {
                grid-template-columns: repeat(2, 1fr);
            }
            .charts-section {
                grid-template-columns: 1fr;
            }
            .chart-container.main-chart {
                grid-column: span 1;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <!-- Header -->
        <header class="dashboard-header">
            <h1>üöÄ Krypto Dashboard <span style="font-size: 0.6em; color: #718096;">v2.1.3</span></h1>
            <div class="header-stats">
                <div class="stat-item">
                    <div class="stat-value" id="portfolioTotal">‚Ç¨0</div>
                    <div class="stat-label">Portfolio</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="lastUpdate">-</div>
                    <div class="stat-label">Update</div>
                </div>
                <a href="performance.html" class="performance-btn">üìä Performance</a>
                <button id="refreshBtn" class="refresh-btn">üîÑ Aktualisieren</button>
            </div>
        </header>

        <!-- DEBUG PANEL -->
        <section class="debug-panel" id="debugPanel">
            <div style="display: flex; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0; color: #4299e1;">üîß Debug Console v2.1.3</h3>
                <button onclick="document.getElementById('debugPanel').style.display='none'" style="margin-left: auto; background: #e53e3e; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">‚ùå Ausblenden</button>
            </div>
            <div id="debugLogs" style="background: #1a202c; padding: 15px; border-radius: 8px; min-height: 100px; max-height: 300px; overflow-y: auto; border: 1px solid #4a5568;">
            </div>
        </section>

        <!-- Market Overview -->
        <section class="market-overview">
            <h3>üìä Markt√ºbersicht</h3>
            <div class="market-cards">
                <div class="market-card">
                    <div class="market-card-value" id="marketSentiment">Bullisch</div>
                    <div class="market-card-label">Sentiment</div>
                </div>
                <div class="market-card">
                    <div class="market-card-value" id="totalCoins">0</div>
                    <div class="market-card-label">Coins</div>
                </div>
                <div class="market-card">
                    <div class="market-card-value" id="avgChange">+0%</div>
                    <div class="market-card-label">‚åÄ 24h</div>
                </div>
                <div class="market-card">
                    <div class="market-card-value" id="topPerformer">-</div>
                    <div class="market-card-label">Top Performer</div>
                </div>
            </div>
        </section>

        <!-- Controls -->
        <section class="controls">
            <div class="control-group">
                <div class="control-item">
                    <label for="coinSelect">Coin:</label>
                    <select id="coinSelect">
                        <option value="">Lade Coins...</option>
                    </select>
                </div>
                
                <div class="control-item">
                    <label>Zeitraum:</label>
                    <div class="time-buttons">
                        <button class="time-btn" data-days="7">7T</button>
                        <button class="time-btn active" data-days="30">30T</button>
                        <button class="time-btn" data-days="90">90T</button>
                    </div>
                </div>

                <div class="control-item">
                    <label>Status:</label>
                    <div class="connection-status" id="connectionStatus">üîÑ Lade...</div>
                </div>
            </div>
        </section>

        <!-- KPI Cards -->
        <section class="kpi-section">
            <div class="kpi-card">
                <div class="kpi-label">Preis</div>
                <div class="kpi-value" id="currentPrice">‚Ç¨0</div>
                <div class="kpi-change neutral" id="priceChange">0%</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-label">RSI</div>
                <div class="kpi-value" id="currentRSI">50</div>
                <div class="kpi-change neutral" id="rsiStatus">Neutral</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-label">ATR Volatilit√§t</div>
                <div class="kpi-value" id="currentATR">0%</div>
                <div class="kpi-change" id="volatilityLevel">üü° Mittel</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-label">Trend (MA)</div>
                <div class="kpi-value" id="currentTrend">‚û°Ô∏è Neutral</div>
                <div class="kpi-change neutral" id="trendStrength">-</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-label">News Sentiment</div>
                <div class="kpi-value" id="currentSentiment">üòê 0</div>
                <div class="kpi-change neutral" id="sentimentCategory">Neutral</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-label">Stop-Loss</div>
                <div class="kpi-value" id="stopLossPrice">‚Ç¨0</div>
                <div class="kpi-change neutral" id="stopLossInfo">-</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-label">Volumen</div>
                <div class="kpi-value" id="currentVolume">üìä 0%</div>
                <div class="kpi-change neutral" id="volumeStatus">Normal</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-label">Fear & Greed</div>
                <div class="kpi-value" id="fearGreedValue">üòê 50</div>
                <div class="kpi-change neutral" id="fearGreedLevel">Neutral</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-label">üéØ Trading Signal</div>
                <div class="kpi-value" id="tradingSignal">‚ö™ HOLD</div>
                <div class="kpi-change neutral" id="signalConfidence">50% Konfidenz</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-label">ü§ñ AI Empfehlung</div>
                <div class="kpi-value" id="aiRecommendation">Hold</div>
                <div class="kpi-change neutral" id="aiReason">Neutral</div>
            </div>
        </section>

        <!-- Charts -->
        <section class="charts-section">
            <div class="chart-container main-chart">
                <h3>üìà Preisentwicklung & Technische Indikatoren</h3>
                <div class="chart-wrapper">
                    <canvas id="mainChart"></canvas>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>üíº Portfolio-Wertentwicklung</h3>
                <div class="chart-wrapper">
                    <canvas id="portfolioChart"></canvas>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>üéØ RSI Indikator</h3>
                <div class="chart-wrapper">
                    <canvas id="rsiChart"></canvas>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>üìä ATR Volatilit√§t & Trend</h3>
                <div class="chart-wrapper">
                    <canvas id="atrChart"></canvas>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>üìà Volumen-Analyse</h3>
                <div class="chart-wrapper">
                    <canvas id="volumeChart"></canvas>
                </div>
            </div>
        </section>

        <!-- Insights -->
        <section class="insights-section">
            <div class="insight-card">
                <h3>üö® Smart Alerts</h3>
                <div class="insights-list" id="smartAlerts">
                    <div class="insight-item">
                        <span class="insight-icon">‚è≥</span>
                        <span>Lade Alerts...</span>
                    </div>
                </div>
            </div>
            
            <div class="insight-card">
                <h3>üì∞ KI News-Analyse</h3>
                <div class="insights-list" id="newsAnalysis">
                    <div class="insight-item">
                        <span class="insight-icon">‚è≥</span>
                        <span>Lade News...</span>
                    </div>
                </div>
            </div>
            
            <div class="insight-card">
                <h3>‚ö° Performance Metrics</h3>
                <div class="insights-list" id="performanceMetrics">
                    <div class="insight-item">
                        <span class="insight-icon">‚è≥</span>
                        <span>Lade Metriken...</span>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script>
        // === KONFIGURATION ===
        const GOOGLE_SHEET_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSYYkwq1mxi-jgRjCHR_HhBk-F7IFjC5raJMwSCGbxM6HQofVDhDdOGBx_eufJNmTJwgaYBzhC64WFv/pub?output=csv";
        
        // === GLOBALE VARIABLEN ===
        let dashboardData = null;
        let chartInstances = {};
        let DOM = {};

        // === DEBUG SYSTEM ===
        function debugLog(message, type = 'info') {
            const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
            const debugContainer = document.getElementById('debugLogs');
            
            const colors = {
                'info': '#81c784',
                'warn': '#ffb74d',
                'error': '#e57373',
                'success': '#68d391',
                'data': '#90cdf4',
                'system': '#b39ddb'
            };
            
            const newLine = document.createElement('div');
            newLine.textContent = `[${timestamp}] ${message}`;
            newLine.style.color = colors[type] || '#e2e8f0';
            newLine.style.marginBottom = '5px';
            newLine.style.borderLeft = `4px solid ${colors[type] || '#e2e8f0'}`;
            newLine.style.paddingLeft = '10px';
            
            debugContainer.appendChild(newLine);
            debugContainer.scrollTop = debugContainer.scrollHeight;
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // === DOM INITIALISIERUNG ===
        function initializeDOM() {
            DOM = {
                portfolioTotal: document.getElementById('portfolioTotal'),
                lastUpdate: document.getElementById('lastUpdate'),
                currentPrice: document.getElementById('currentPrice'),
                priceChange: document.getElementById('priceChange'),
                currentRSI: document.getElementById('currentRSI'),
                rsiStatus: document.getElementById('rsiStatus'),
                currentATR: document.getElementById('currentATR'),
                volatilityLevel: document.getElementById('volatilityLevel'),
                currentTrend: document.getElementById('currentTrend'),
                trendStrength: document.getElementById('trendStrength'),
                currentSentiment: document.getElementById('currentSentiment'),
                sentimentCategory: document.getElementById('sentimentCategory'),
                stopLossPrice: document.getElementById('stopLossPrice'),
                stopLossInfo: document.getElementById('stopLossInfo'),
                currentVolume: document.getElementById('currentVolume'),
                volumeStatus: document.getElementById('volumeStatus'),
                fearGreedValue: document.getElementById('fearGreedValue'),
                fearGreedLevel: document.getElementById('fearGreedLevel'),
                tradingSignal: document.getElementById('tradingSignal'),
                signalConfidence: document.getElementById('signalConfidence'),
                aiRecommendation: document.getElementById('aiRecommendation'),
                aiReason: document.getElementById('aiReason'),
                marketSentiment: document.getElementById('marketSentiment'),
                totalCoins: document.getElementById('totalCoins'),
                avgChange: document.getElementById('avgChange'),
                topPerformer: document.getElementById('topPerformer'),
                coinSelect: document.getElementById('coinSelect'),
                connectionStatus: document.getElementById('connectionStatus'),
                refreshBtn: document.getElementById('refreshBtn'),
                mainChart: document.getElementById('mainChart'),
                portfolioChart: document.getElementById('portfolioChart'),
                rsiChart: document.getElementById('rsiChart'),
                atrChart: document.getElementById('atrChart'),
                volumeChart: document.getElementById('volumeChart'),
                smartAlerts: document.getElementById('smartAlerts'),
                newsAnalysis: document.getElementById('newsAnalysis'),
                performanceMetrics: document.getElementById('performanceMetrics')
            };
        }

        // === HILFSFUNKTIONEN (FEHLTEN IM ORIGINAL) ===
        function getRSIStatus(rsi) {
            if (rsi > 70) return '√úberkauft';
            if (rsi < 30) return '√úberverkauft';
            return 'Neutral';
        }

        function getVolatilityLevel(atr) {
            if (atr > 5) return 'üî¥ Hoch';
            if (atr > 2) return 'üü° Mittel';
            return 'üü¢ Niedrig';
        }

        function getTrendDirection(trend) {
            if (trend === 'BULLISH' || trend === 'BUY') return '‚ÜóÔ∏è Aufw√§rts';
            if (trend === 'BEARISH' || trend === 'SELL') return '‚ÜòÔ∏è Abw√§rts';
            return '‚û°Ô∏è Neutral';
        }

        function getSentimentCategory(sentiment) {
            if (sentiment > 3) return 'Bullish';
            if (sentiment < -3) return 'Bearish';
            return 'Neutral';
        }

        function getVolumeStatus(volume) {
            if (volume > 150) return 'Sehr Hoch';
            if (volume > 100) return 'Hoch';
            if (volume < 50) return 'Niedrig';
            return 'Normal';
        }

        function getFearGreedLevel(value) {
            if (value > 75) return 'Extreme Greed';
            if (value > 50) return 'Greed';
            if (value < 25) return 'Fear';
            if (value < 50) return 'Neutral';
            return 'Neutral';
        }

        function getTradingSignal(coinData) {
            const signals = coinData.strategySignal || [];
            const confidences = coinData.confidenceScore || [];
            
            if (signals.length === 0) return { signal: '‚ö™ HOLD', confidence: '50' };
            
            const signal = signals[signals.length - 1] || 'HOLD';
            const confidence = (confidences[confidences.length - 1] || 0.5) * 100;
            
            let displaySignal = '‚ö™ HOLD';
            if (signal === 'BUY') displaySignal = 'üü¢ BUY';
            if (signal === 'SELL') displaySignal = 'üî¥ SELL';
            
            return { signal: displaySignal, confidence: confidence.toFixed(0) };
        }

        function getAIRecommendation(coinData) {
            const recommendations = coinData.aiRecommendation || [];
            const sentiments = coinData.newsSentiment || [];
            
            const recommendation = recommendations[recommendations.length - 1] || 'Hold';
            const sentiment = sentiments[sentiments.length - 1] || 'Neutral';
            
            return { recommendation, reason: sentiment };
        }

        function getMarketSentiment(coins) {
            let bullishCount = 0;
            let bearishCount = 0;
            let totalCoins = 0;
            
            for (const coin in coins) {
                const signals = coins[coin].strategySignal || [];
                const latestSignal = signals[signals.length - 1];
                
                if (latestSignal) {
                    totalCoins++;
                    if (latestSignal === 'BUY') bullishCount++;
                    if (latestSignal === 'SELL') bearishCount++;
                }
            }
            
            if (bullishCount > bearishCount) return 'Bullisch';
            if (bearishCount > bullishCount) return 'B√§risch';
            return 'Neutral';
        }

        function getAverageChange(coins) {
            let totalChange = 0;
            let count = 0;
            
            for (const coin in coins) {
                const prices = coins[coin].prices;
                if (prices && prices.length >= 2) {
                    const latest = prices[prices.length - 1];
                    const previous = prices[prices.length - 2];
                    const change = ((latest - previous) / previous) * 100;
                    totalChange += change;
                    count++;
                }
            }
            
            return count > 0 ? totalChange / count : 0;
        }

        function getTopPerformer(coins) {
            let topCoin = '';
            let maxChange = -Infinity;
            
            for (const coin in coins) {
                const prices = coins[coin].prices;
                if (prices && prices.length >= 2) {
                    const latest = prices[prices.length - 1];
                    const previous = prices[prices.length - 2];
                    const change = ((latest - previous) / previous) * 100;
                    if (change > maxChange) {
                        maxChange = change;
                        topCoin = coin;
                    }
                }
            }
            
            return topCoin || 'N/A';
        }

        // === CSV PARSING ===
        function parseCSVData(csvText) {
            debugLog('üîÑ Starte CSV-Parsing...', 'info');
            const lines = csvText.replace(/\r\n/g, '\n').split('\n').filter(line => line.trim());
            
            if (lines.length < 2) {
                throw new Error('CSV ist leer oder hat nur Header');
            }
            
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            debugLog(`üìã Headers gefunden: ${headers.join(', ')}`, 'data');
            
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim()) {
                    const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] || '';
                    });
                    
                    // Nur g√ºltige Zeilen
                    const coinName = row.Coin_Name || row.coin;
                    if (coinName && coinName !== '' && coinName !== 'Unknown') {
                        data.push(row);
                    }
                }
            }
            
            debugLog(`‚úÖ CSV-Parsing abgeschlossen: ${data.length} Zeilen`, 'success');
            return data;
        }

        // === DEUTSCHE ZAHLEN KONVERTIERUNG ===
        function parseGermanNumber(str) {
            if (!str || typeof str !== 'string') return 0;
            const cleaned = str.trim();
            
            if (cleaned === '0' || cleaned === '0.0' || cleaned === '0,0') {
                return 0;
            }
            
            // Deutsche Format: 1.234.567,89
            if (cleaned.includes(',')) {
                return parseFloat(cleaned.replace(/\./g, '').replace(',', '.')) || 0;
            }
            
            // Mehrere Punkte = Tausendertrennzeichen
            const parts = cleaned.split('.');
            if (parts.length > 2) {
                return parseFloat(cleaned.replace(/\./g, '')) || 0;
            }
            
            return parseFloat(cleaned) || 0;
        }

        // === DATENVERARBEITUNG ===
        function processSheetData(data) {
            debugLog('üîÑ Verarbeite Google Sheets Daten...', 'info');
            
            const coins = {};
            let totalPortfolioValue = 0;
            
            // Gruppiere nach Coin
            data.forEach(row => {
                const coinName = row['Coin_Name'];
                if (!coinName || coinName === '' || coinName === 'Unknown') return;
                
                if (!coins[coinName]) {
                    coins[coinName] = {
                        prices: [],
                        dates: [],
                        rsi: [],
                        sentiment: [],
                        volume: [],
                        portfolioValues: [],
                        holdings: [],
                        atr: [],
                        atrPercentage: [],
                        volatilityLevel: [],
                        stopLoss: [],
                        stochK: [],
                        williamsR: [],
                        macdSignal: [],
                        maTrend: [],
                        newsCategory: [],
                        strategySignal: [],
                        confidenceScore: [],
                        aiRecommendation: [],
                        newsSentiment: [],
                        rawData: []
                    };
                }
                
                coins[coinName].rawData.push(row);
            });
            
            debugLog(`üìä Gefundene Coins: ${Object.keys(coins).join(', ')}`, 'data');
            
            // Verarbeite jeden Coin
            for (const coinName in coins) {
                const coinData = coins[coinName];
                
                // Sortiere nach Zeitstempel (neueste zuerst)
                coinData.rawData.sort((a, b) => {
                    const dateA = new Date(a.Zeitstempel || '1970-01-01');
                    const dateB = new Date(b.Zeitstempel || '1970-01-01');
                    return dateB - dateA;
                });
                
                // Portfolio-Wert vom neuesten Eintrag
                const newestEntry = coinData.rawData[0];
                const wertEur = parseGermanNumber(newestEntry['Wert_EUR'] || '0');
                totalPortfolioValue += wertEur;
                
                // F√ºlle Arrays f√ºr Charts (√§lteste zuerst f√ºr Charts)
                coinData.rawData.reverse().forEach(row => {
                    coinData.dates.push(row['Zeitstempel'] || new Date().toISOString());
                    coinData.prices.push(parseGermanNumber(row['Preis_EUR'] || '0'));
                    coinData.rsi.push(parseFloat(row['RSI'] || 50));
                    coinData.sentiment.push(parseFloat(row['News_Sentiment'] || 0));
                    coinData.volume.push(parseFloat(row['Volume_Ratio'] || 100));
                    coinData.portfolioValues.push(parseGermanNumber(row['Wert_EUR'] || '0'));
                    coinData.holdings.push(parseGermanNumber(row['Bestand'] || '0'));
                    coinData.atr.push(parseFloat(row['ATR'] || 0));
                    coinData.atrPercentage.push(parseFloat(row['ATR_Percentage'] || 0));
                    coinData.volatilityLevel.push(row['Volatility_Level'] || 'üü° Mittel');
                    coinData.stopLoss.push(parseFloat(row['Stop_Loss_Long'] || 0));
                    coinData.strategySignal.push(row['Strategy_Signal'] || 'HOLD');
                    coinData.confidenceScore.push(parseFloat(row['Confidence_Score'] || 0.5));
                    coinData.aiRecommendation.push(row['AI_Recommendation'] || 'Hold');
                    coinData.newsSentiment.push(row['News_Category'] || 'Neutral');
                });
            }
            
            debugLog(`üí∞ Portfolio-Gesamtwert: ‚Ç¨${totalPortfolioValue.toLocaleString('de-DE')}`, 'success');
            
            return {
                coins: coins,
                portfolio_total: totalPortfolioValue,
                last_update: new Date().toISOString()
            };
        }

        // === VERBESSERTE DEMO DATEN (Aktualisiert mit Backend-Signalen) ===
        function getEnhancedDemoData() {
            const baseData = [
                { coin: 'Bitcoin', signal: 'HOLD', rsi: 48, atr: 2.4, sentiment: 'Neutral', confidence: 0.30, ai: 'Mixed signals' },
                { coin: 'Ethereum', signal: 'HOLD', rsi: 67, atr: 5.1, sentiment: 'Neutral', confidence: 0.30, ai: 'High volatility' },
                { coin: 'BNB', signal: 'BUY', rsi: 66, atr: 3.8, sentiment: 'Bullish', confidence: 0.75, ai: 'BB Breakout + MACD bullish | Volume confirmation' },
                { coin: 'Cardano', signal: 'HOLD', rsi: 60, atr: 7.2, sentiment: 'Neutral', confidence: 0.30, ai: 'High volatility' },
                { coin: 'Solana', signal: 'HOLD', rsi: 59, atr: 5.8, sentiment: 'Neutral', confidence: 0.30, ai: 'High volatility' },
                { coin: 'Polkadot', signal: 'HOLD', rsi: 56, atr: 5.9, sentiment: 'Neutral', confidence: 0.30, ai: 'High volatility' },
                { coin: 'Chainlink', signal: 'HOLD', rsi: 65, atr: 7.7, sentiment: 'Neutral', confidence: 0.30, ai: 'High volatility' },
                { coin: 'Dogecoin', signal: 'HOLD', rsi: 56, atr: 7.2, sentiment: 'Neutral', confidence: 0.30, ai: 'High volatility' },
                { coin: 'Toncoin', signal: 'HOLD', rsi: 53, atr: 4.9, sentiment: 'Neutral', confidence: 0.30, ai: 'High volatility' },
                { coin: 'XRP', signal: 'HOLD', rsi: 50, atr: 6.0, sentiment: 'Neutral', confidence: 0.30, ai: 'High volatility' }
            ];

            // Generiere realistische Zeitreihen-Daten
            const now = new Date();
            const data = [];
            
            baseData.forEach((coin, coinIndex) => {
                for (let day = 30; day >= 0; day--) {
                    const date = new Date(now);
                    date.setDate(date.getDate() - day);
                    
                    // Simuliere Preisbewegungen
                    const basePrice = 1000 + (coinIndex * 500);
                    const volatility = coin.atr / 100;
                    const trendDirection = coin.signal === 'BUY' ? 1 : coin.signal === 'SELL' ? -1 : 0;
                    const randomChange = (Math.random() - 0.5) * volatility * basePrice;
                    const trendChange = trendDirection * (30 - day) * 2;
                    const price = basePrice + randomChange + trendChange;
                    
                    // Simuliere RSI Schwankungen
                    const rsiBase = coin.rsi;
                    const rsiNoise = (Math.random() - 0.5) * 10;
                    const rsi = Math.max(10, Math.min(90, rsiBase + rsiNoise));
                    
                    // Simuliere Volumen
                    const baseVolume = 1000000000 + (coinIndex * 100000000);
                    const volumeMultiplier = 0.8 + (Math.random() * 0.4); // 0.8 - 1.2
                    const volume = baseVolume * volumeMultiplier;
                    
                    data.push({
                        timestamp: date.toISOString(),
                        coin: coin.coin,
                        current_price: price,
                        price_change_24h: (Math.random() - 0.5) * 20,
                        rsi: rsi,
                        volume_24h: volume,
                        atr: coin.atr * basePrice / 100,
                        strategy_signal: coin.signal,
                        confidence_score: coin.confidence,
                        ai_recommendation: coin.ai,
                        news_sentiment: coin.sentiment,
                        portfolio_value: price * (0.1 + Math.random() * 0.9) // Zuf√§llige Holdings
                    });
                }
            });
            
            return data;
        }

        // === VERBESSERTE DATENVERARBEITUNG ===
        function processMarketData(data) {
            debugLog('üîÑ Verarbeite Markt-Daten...', 'info');
            
            const coins = {};
            let totalPortfolioValue = 0;
            
            // Gruppiere und sortiere nach Coin und Datum
            data.forEach(row => {
                const coinName = row.coin;
                if (!coinName) return;
                
                if (!coins[coinName]) {
                    coins[coinName] = {
                        prices: [],
                        dates: [],
                        rsi: [],
                        sentiment: [],
                        volume: [],
                        portfolioValues: [],
                        holdings: [],
                        atr: [],
                        atrPercentage: [],
                        volatilityLevel: [],
                        stopLoss: [],
                        strategySignal: [],
                        confidenceScore: [],
                        aiRecommendation: [],
                        newsSentiment: [],
                        rawData: []
                    };
                }
                
                coins[coinName].rawData.push(row);
            });
            
            // Verarbeite jeden Coin
            for (const coinName in coins) {
                const coinData = coins[coinName];
                
                // Sortiere nach Datum
                coinData.rawData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                coinData.rawData.forEach(row => {
                    const price = parseFloat(row.current_price || 0);
                    const atr = parseFloat(row.atr || 0);
                    const portfolioValue = parseFloat(row.portfolio_value || 0);
                    
                    coinData.dates.push(row.timestamp || new Date().toISOString());
                    coinData.prices.push(price);
                    coinData.rsi.push(parseFloat(row.rsi || 50));
                    
                    // Konvertiere Sentiment zu Zahlen
                    let sentimentValue = 0;
                    const sentiment = row.news_sentiment || 'Neutral';
                    if (sentiment.includes('Bullish')) sentimentValue = sentiment.includes('Very') ? 8 : 5;
                    else if (sentiment.includes('Bearish')) sentimentValue = sentiment.includes('Very') ? -8 : -5;
                    
                    coinData.sentiment.push(sentimentValue);
                    coinData.volume.push(parseFloat(row.volume_24h || 100000000) / 1000000); // Normalisiert in Millionen
                    coinData.portfolioValues.push(portfolioValue);
                    coinData.holdings.push(portfolioValue / price || 0);
                    coinData.atr.push(atr);
                    coinData.atrPercentage.push(price > 0 ? (atr / price) * 100 : 0);
                    coinData.volatilityLevel.push(atr > 100 ? 'üî¥ Hoch' : atr > 10 ? 'üü° Mittel' : 'üü¢ Niedrig');
                    coinData.stopLoss.push(price - (atr * 2));
                    coinData.strategySignal.push(row.strategy_signal || 'HOLD');
                    coinData.confidenceScore.push(parseFloat(row.confidence_score || 0.5));
                    coinData.aiRecommendation.push(row.ai_recommendation || 'Hold');
                    coinData.newsSentiment.push(row.news_sentiment || 'Neutral');
                });
                
                // Addiere zum Portfolio-Gesamtwert (letzter Wert)
                if (coinData.portfolioValues.length > 0) {
                    totalPortfolioValue += coinData.portfolioValues[coinData.portfolioValues.length - 1];
                }
            }
            
            debugLog(`üìä Verarbeitete Coins: ${Object.keys(coins).join(', ')}`, 'data');
            debugLog(`üí∞ Portfolio-Gesamtwert: ‚Ç¨${totalPortfolioValue.toLocaleString('de-DE')}`, 'success');
            
            return {
                coins: coins,
                portfolio_total: totalPortfolioValue,
                last_update: new Date().toISOString()
            };
        }

        // === VERBESSERTE CHART-AKTUALISIERUNG ===
        function updateAllCharts(marketData) {
            debugLog('üìä Aktualisiere alle Charts...', 'info');
            
            // Hauptchart mit allen Coins
            updateMainChart(marketData);
            
            // Einzelne Coin-Charts (nur ausgew√§hlter Coin)
            const selected = DOM.coinSelect.value || Object.keys(marketData.coins)[0];
            if (selected && marketData.coins[selected]) {
                updateCoinChart(selected, marketData.coins[selected]);
            }
            
            // RSI Chart f√ºr ausgew√§hlten Coin
            renderRSIChart(selected ? marketData.coins[selected] : null);

            // Portfolio Verteilung
            renderPortfolioChart(marketData);

            // ATR & Volume Charts (gesamt)
            renderATRChart(marketData);
            renderVolumeChart(marketData);
            
            debugLog('‚úÖ Alle Charts aktualisiert', 'success');
        }
        
        function updateMainChart(marketData) {
            const ctx = DOM.mainChart.getContext('2d');
            if (chartInstances.main) chartInstances.main.destroy();

            const datasets = [];
            const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6'];
            let colorIndex = 0;
            for (const coinName in marketData.coins) {
                const coinData = marketData.coins[coinName];
                const color = colors[colorIndex % colors.length];
                datasets.push({
                    label: `${coinName} Preis`,
                    data: coinData.prices,
                    borderColor: color,
                    backgroundColor: color + '20',
                    fill: false,
                    tension: 0.1
                });
                colorIndex++;
            }

            const firstCoin = Object.values(marketData.coins)[0];
            const labels = firstCoin ? firstCoin.dates.map(date => new Date(date).toLocaleDateString('de-DE', { month: 'short', day: 'numeric' })) : [];

            chartInstances.main = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: { responsive: true, maintainAspectRatio: false }
            });
        }
        
        function updateCoinChart(coinName, coinData) {
            const chartElement = document.getElementById(`chart-${coinName.toLowerCase()}`);
            if (!chartElement) return;
            
            const ctx = chartElement.getContext('2d');
            const existingChart = Chart.getChart(ctx);
            
            if (existingChart) {
                existingChart.destroy();
            }
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: coinData.dates.map(date => 
                        new Date(date).toLocaleDateString('de-DE', { 
                            month: 'short', 
                            day: 'numeric' 
                        })
                    ),
                    datasets: [{
                        label: `${coinName} Preis`,
                        data: coinData.prices,
                        borderColor: coinName === 'Bitcoin' ? '#f7931a' : 
                                   coinName === 'Ethereum' ? '#627eea' : 
                                   coinName === 'Solana' ? '#9945ff' : '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        fill: true,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return '‚Ç¨' + value.toLocaleString('de-DE');
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }
        
        function updateTradingSignalChart(marketData) {
            // Optional: Falls ein Signal-Chart existiert
            const el = document.getElementById('signalChart');
            if (!el) return;
            const ctx = el.getContext('2d');
            const existingChart = Chart.getChart(ctx);
            
            if (existingChart) {
                existingChart.destroy();
            }
            
            // Sammle Signal-Daten
            const signalData = {};
            const colors = { 'BUY': '#10b981', 'SELL': '#ef4444', 'HOLD': '#f59e0b' };
            
            for (const coinName in marketData.coins) {
                const coinData = marketData.coins[coinName];
                coinData.strategySignal.forEach(signal => {
                    signalData[signal] = (signalData[signal] || 0) + 1;
                });
            }
            
            new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(signalData),
                    datasets: [{
                        data: Object.values(signalData),
                        backgroundColor: Object.keys(signalData).map(signal => colors[signal] || '#6b7280'),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }
        
        function renderATRChart(marketData) {
            const el = DOM.atrChart; // id="atrChart"
            if (!el) return;
            const ctx = el.getContext('2d');
            const existingChart = Chart.getChart(ctx);
            
            if (existingChart) {
                existingChart.destroy();
            }
            
            const datasets = [];
            const colors = ['#3b82f6', '#10b981', '#f59e0b'];
            let colorIndex = 0;
            
            for (const coinName in marketData.coins) {
                const coinData = marketData.coins[coinName];
                datasets.push({
                    label: `${coinName} ATR %`,
                    data: coinData.atrPercentage,
                    borderColor: colors[colorIndex % colors.length],
                    backgroundColor: colors[colorIndex % colors.length] + '20',
                    fill: false,
                    tension: 0.1
                });
                colorIndex++;
            }
            
            const firstCoin = Object.values(marketData.coins)[0];
            
            chartInstances.atr = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: firstCoin ? firstCoin.dates.map(date => 
                        new Date(date).toLocaleDateString('de-DE', { 
                            month: 'short', 
                            day: 'numeric' 
                        })
                    ) : [],
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: true }
                    }
                }
            });
        }
        
        function renderVolumeChart(marketData) {
            const el = DOM.volumeChart; // id="volumeChart"
            if (!el) return;
            const ctx = el.getContext('2d');
            const existingChart = Chart.getChart(ctx);
            
            if (existingChart) {
                existingChart.destroy();
            }
            
            const datasets = [];
            const colors = ['#3b82f6', '#10b981', '#f59e0b'];
            let colorIndex = 0;
            
            for (const coinName in marketData.coins) {
                const coinData = marketData.coins[coinName];
                datasets.push({
                    label: `${coinName} Volumen (M‚Ç¨)`,
                    data: coinData.volume,
                    backgroundColor: colors[colorIndex % colors.length] + '80',
                    borderColor: colors[colorIndex % colors.length],
                    borderWidth: 1
                });
                colorIndex++;
            }
            
            const firstCoin = Object.values(marketData.coins)[0];
            
            chartInstances.volume = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: firstCoin ? firstCoin.dates.map(date => 
                        new Date(date).toLocaleDateString('de-DE', { 
                            month: 'short', 
                            day: 'numeric' 
                        })
                    ) : [],
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString('de-DE') + 'M‚Ç¨';
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: true }
                    }
                }
            });
        }

        function renderRSIChart(coinData) {
            if (!coinData) return;
            const ctx = DOM.rsiChart.getContext('2d');
            if (chartInstances.rsi) chartInstances.rsi.destroy();
            chartInstances.rsi = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: coinData.dates.map(d => new Date(d).toLocaleDateString('de-DE')),
                    datasets: [{
                        label: 'RSI',
                        data: coinData.rsi,
                        borderColor: '#f59e0b',
                        backgroundColor: 'rgba(245, 158, 11, 0.1)',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { y: { min: 0, max: 100 } }
                }
            });
        }

        function renderPortfolioChart(marketData) {
            const labels = [];
            const values = [];
            for (const coin in marketData.coins) {
                const arr = marketData.coins[coin].portfolioValues;
                if (arr && arr.length) {
                    labels.push(coin);
                    values.push(arr[arr.length - 1]);
                }
            }
            const ctx = DOM.portfolioChart.getContext('2d');
            if (chartInstances.portfolio) chartInstances.portfolio.destroy();
            chartInstances.portfolio = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels,
                    datasets: [{
                        data: values,
                        backgroundColor: ['#667eea', '#48bb78', '#f59e0b', '#f56565', '#ed64a6', '#9f7aea', '#4299e1', '#38b2ac']
                    }]
                },
                options: { responsive: true, maintainAspectRatio: false }
            });
        }

        // === HAUPTFUNKTION: DATEN LADEN ===
        async function loadDashboardData() {
            debugLog('üì° Starte Datenladung...', 'info');
            
            try {
                // Versuche zuerst Google Sheets zu laden
                if (GOOGLE_SHEET_CSV_URL && GOOGLE_SHEET_CSV_URL !== '') {
                    debugLog('üîó Lade von Google Sheets...', 'info');
                    
                    const response = await fetch(GOOGLE_SHEET_CSV_URL);
                    if (response.ok) {
                        const csvText = await response.text();
                        const parsedData = parseCSVData(csvText);
                        
                        if (parsedData && parsedData.length > 0) {
                            // Pr√ºfe ob deutsche oder englische Spalten
                            if (parsedData[0]['Coin_Name']) {
                                dashboardData = processSheetData(parsedData);
                                DOM.connectionStatus.textContent = '‚úÖ Live-Daten';
                                DOM.connectionStatus.className = 'connection-status connected';
                            } else if (parsedData[0]['coin']) {
                                dashboardData = processMarketData(parsedData);
                                DOM.connectionStatus.textContent = '‚úÖ Live-Daten';
                                DOM.connectionStatus.className = 'connection-status connected';
                            }
                            
                            debugLog('‚úÖ Google Sheets Daten geladen', 'success');
                            updateDashboardDisplay();
                            return;
                        }
                    }
                }
            } catch (error) {
                debugLog(`‚ö†Ô∏è Fehler beim Laden der Google Sheets: ${error.message}`, 'error');
            }
            
            // Fallback zu Demo-Daten
            debugLog('üéÆ Lade Demo-Daten...', 'warn');
            // Nutze verbesserte Demo-Daten mit passendem Schema
            const parsedData = getEnhancedDemoData();
            dashboardData = processMarketData(parsedData);
            
            DOM.connectionStatus.textContent = 'üéÆ Demo-Modus';
            DOM.connectionStatus.className = 'connection-status demo';
            
            debugLog('‚úÖ Demo-Daten geladen', 'success');
            updateDashboardDisplay();
        }

        // === DASHBOARD ANZEIGE AKTUALISIEREN ===
        function updateDashboardDisplay() {
            debugLog('üîÑ Aktualisiere Dashboard-Anzeige...', 'info');
            
            if (!dashboardData || !dashboardData.coins) {
                debugLog('‚ùå Keine Dashboard-Daten vorhanden!', 'error');
                return;
            }
            
            // Aktualisiere Coin-Dropdown
            updateCoinDropdown();
            
            // Setze erstes Coin als Standard
            const firstCoin = Object.keys(dashboardData.coins)[0];
            if (firstCoin && DOM.coinSelect.value === '') {
                DOM.coinSelect.value = firstCoin;
            }
            
            // Aktualisiere alle Anzeigen
            updateSelectedCoinDisplay();
            updateMarketOverview();
            updateAllCharts(dashboardData);
            updateInsights();
            
            // Aktualisiere Header
            DOM.portfolioTotal.textContent = `‚Ç¨${dashboardData.portfolio_total.toLocaleString('de-DE', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
            DOM.lastUpdate.textContent = new Date(dashboardData.last_update).toLocaleTimeString('de-DE');
            
            debugLog('‚úÖ Dashboard-Anzeige aktualisiert', 'success');
        }

        function updateCoinDropdown() {
            DOM.coinSelect.innerHTML = '';
            
            for (const coinName in dashboardData.coins) {
                const option = document.createElement('option');
                option.value = coinName;
                option.textContent = coinName;
                DOM.coinSelect.appendChild(option);
            }
            
            debugLog(`ü™ô ${Object.keys(dashboardData.coins).length} Coins im Dropdown`, 'info');
        }

        function updateSelectedCoinDisplay() {
            const selectedCoin = DOM.coinSelect.value;
            if (!selectedCoin || !dashboardData.coins[selectedCoin]) return;
            
            const coinData = dashboardData.coins[selectedCoin];
            const latestIndex = coinData.prices.length - 1;
            
            // Preis
            const currentPrice = coinData.prices[latestIndex] || 0;
            DOM.currentPrice.textContent = `‚Ç¨${currentPrice.toLocaleString('de-DE', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
            
            // Preis-√Ñnderung
            if (coinData.prices.length >= 2) {
                const previousPrice = coinData.prices[latestIndex - 1];
                const change = previousPrice > 0 ? ((currentPrice - previousPrice) / previousPrice) * 100 : 0;
                DOM.priceChange.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                DOM.priceChange.className = `kpi-change ${change >= 0 ? 'positive' : 'negative'}`;
            }
            
            // RSI
            const rsi = coinData.rsi[latestIndex] || 50;
            DOM.currentRSI.textContent = rsi.toFixed(0);
            DOM.rsiStatus.textContent = getRSIStatus(rsi);
            DOM.rsiStatus.className = `kpi-change ${rsi > 70 || rsi < 30 ? 'negative' : 'neutral'}`;
            
            // ATR
            const atr = coinData.atrPercentage[latestIndex] || 0;
            DOM.currentATR.textContent = `${atr.toFixed(2)}%`;
            DOM.volatilityLevel.textContent = getVolatilityLevel(atr);
            
            // Trading Signal
            const tradingSignal = getTradingSignal(coinData);
            DOM.tradingSignal.textContent = tradingSignal.signal;
            DOM.signalConfidence.textContent = `${tradingSignal.confidence}% Konfidenz`;
            
            // AI Empfehlung
            const aiReco = getAIRecommendation(coinData);
            DOM.aiRecommendation.textContent = aiReco.recommendation;
            DOM.aiReason.textContent = aiReco.reason;
            
            // Weitere KPIs
            const sentiment = coinData.sentiment[latestIndex] || 0;
            DOM.currentSentiment.textContent = `${sentiment > 0 ? 'üòä' : sentiment < 0 ? 'üòü' : 'üòê'} ${Math.abs(sentiment).toFixed(1)}`;
            DOM.sentimentCategory.textContent = getSentimentCategory(sentiment);
            
            const stopLoss = coinData.stopLoss[latestIndex] || 0;
            DOM.stopLossPrice.textContent = `‚Ç¨${stopLoss.toFixed(2)}`;
            DOM.stopLossInfo.textContent = `-2x ATR`;
            
            const volume = coinData.volume[latestIndex] || 100;
            DOM.currentVolume.textContent = `üìà ${volume > 100 ? '+' : ''}${(volume - 100).toFixed(0)}%`;
            DOM.volumeStatus.textContent = getVolumeStatus(volume);
        }

        function updateMarketOverview() {
            DOM.marketSentiment.textContent = getMarketSentiment(dashboardData.coins);
            DOM.totalCoins.textContent = Object.keys(dashboardData.coins).length;
            DOM.avgChange.textContent = `${getAverageChange(dashboardData.coins) >= 0 ? '+' : ''}${getAverageChange(dashboardData.coins).toFixed(2)}%`;
            DOM.topPerformer.textContent = getTopPerformer(dashboardData.coins);
        }

        function updateInsights() {
            // Smart Alerts
            DOM.smartAlerts.innerHTML = '';
            for (const coinName in dashboardData.coins) {
                const coin = dashboardData.coins[coinName];
                const rsi = coin.rsi[coin.rsi.length - 1];
                
                if (rsi < 30) {
                    const item = document.createElement('div');
                    item.className = 'insight-item';
                    item.innerHTML = `<span class="insight-icon">üü¢</span><span>${coinName} RSI bei ${rsi.toFixed(0)} - Potentielle Kaufgelegenheit!</span>`;
                    DOM.smartAlerts.appendChild(item);
                } else if (rsi > 70) {
                    const item = document.createElement('div');
                    item.className = 'insight-item';
                    item.innerHTML = `<span class="insight-icon">üî¥</span><span>${coinName} RSI bei ${rsi.toFixed(0)} - √úberkauft!</span>`;
                    DOM.smartAlerts.appendChild(item);
                }
            }
            
            if (DOM.smartAlerts.children.length === 0) {
                DOM.smartAlerts.innerHTML = '<div class="insight-item"><span class="insight-icon">‚úÖ</span><span>Keine kritischen Alerts</span></div>';
            }

            // News Analysis (KI)
            DOM.newsAnalysis.innerHTML = '';
            for (const coinName in dashboardData.coins) {
                const coin = dashboardData.coins[coinName];
                const sentiment = coin.newsSentiment[coin.newsSentiment.length - 1] || 'Neutral';
                const ai = coin.aiRecommendation[coin.aiRecommendation.length - 1] || 'Hold';
                const item = document.createElement('div');
                item.className = 'insight-item';
                const icon = sentiment.includes('Bull') ? 'üü¢' : sentiment.includes('Bear') ? 'üî¥' : 'üü°';
                item.innerHTML = `<span class="insight-icon">${icon}</span><span>${coinName}: ${sentiment} ‚Ä¢ AI: ${ai}</span>`;
                DOM.newsAnalysis.appendChild(item);
            }
            if (DOM.newsAnalysis.children.length === 0) {
                DOM.newsAnalysis.innerHTML = '<div class="insight-item"><span class="insight-icon">‚ÑπÔ∏è</span><span>Keine News verf√ºgbar</span></div>';
            }

            // Performance Metrics (einfacher √úberblick)
            DOM.performanceMetrics.innerHTML = '';
            let winners = 0, losers = 0;
            for (const coinName in dashboardData.coins) {
                const prices = dashboardData.coins[coinName].prices;
                if (prices.length >= 2) {
                    const ch = ((prices[prices.length - 1] - prices[prices.length - 2]) / prices[prices.length - 2]) * 100;
                    if (ch >= 0) winners++; else losers++;
                }
            }
            const total = winners + losers;
            const winRate = total ? Math.round((winners / total) * 100) : 0;
            const perf = document.createElement('div');
            perf.className = 'insight-item';
            perf.innerHTML = `<span class="insight-icon">üìà</span><span>Win-Rate (letzte Periode): ${winRate}% ‚Ä¢ Gewinner: ${winners} ‚Ä¢ Verlierer: ${losers}</span>`;
            DOM.performanceMetrics.appendChild(perf);
        }

        // === LEGACY CHART UPDATE (f√ºr Coin-Dropdown) ===
        function updateCharts() {
            // Aktualisiere nur die einzelnen Coin-Charts beim Coin-Wechsel
            const selectedCoin = DOM.coinSelect.value;
            if (!selectedCoin || !dashboardData.coins[selectedCoin]) return;
            
            const coinData = dashboardData.coins[selectedCoin];
            updateCoinChart(selectedCoin, coinData);
            
            debugLog(`üìä Chart f√ºr ${selectedCoin} aktualisiert`, 'info');
        }

        // === EVENT LISTENERS ===
        function setupEventListeners() {
            DOM.coinSelect.addEventListener('change', () => {
                debugLog(`ü™ô Coin gewechselt zu: ${DOM.coinSelect.value}`, 'info');
                updateSelectedCoinDisplay();
                updateCharts();
            });
            
            DOM.refreshBtn.addEventListener('click', () => {
                debugLog('üîÑ Manuelles Aktualisieren...', 'info');
                loadDashboardData();
            });
            
            // Zeit-Buttons
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    debugLog(`‚è±Ô∏è Zeitraum ge√§ndert zu: ${e.target.dataset.days} Tage`, 'info');
                    updateCharts();
                });
            });
        }

        // === INITIALISIERUNG ===
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('üöÄ Crypto Dashboard v2.1.3 wird initialisiert...', 'system');
            
            initializeDOM();
            debugLog('‚úÖ DOM initialisiert', 'success');
            
            setupEventListeners();
            debugLog('‚úÖ Event Listeners eingerichtet', 'success');
            
            loadDashboardData();
            
            // Auto-Refresh alle 5 Minuten
            setInterval(() => {
                debugLog('‚è∞ Auto-Refresh...', 'info');
                loadDashboardData();
            }, 5 * 60 * 1000);
        });
    </script>
</body>
</html>
